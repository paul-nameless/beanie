{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Beanie - is an asynchronous ODM for MongoDB, based on Motor and Pydantic . It uses an abstraction over Pydantic models and Motor collections to work with the database. Class Document allows to create, replace, update, get, find and aggregate. Here you can see, how to use Beanie, in simple examples: Installation PIP pip install beanie Poetry poetry add beanie Usage Init import asyncio from typing import List import motor from beanie import Document from beanie import init_beanie from pydantic import BaseModel # CREATE BEANIE DOCUMENT STRUCTURE class SubDocument(BaseModel): test_str: str class DocumentTestModel(Document): test_int: int test_list: List[SubDocument] test_str: str async def main(): # CREATE MOTOR CLIENT AND DB client = motor.motor_asyncio.AsyncIOMotorClient( \"mongodb://user:pass@host:27017/db\", serverSelectionTimeoutMS=100 ) db = client.beanie_db # INIT BEANIE await init_beanie(database=db, document_models=[DocumentTestModel]) asyncio.run(main()) init_beanie supports not only list of classes for the document_models parameter, but also strings with the dot separated paths. Example: await init_beanie( database=db, document_models=[ \"app.models.DemoDocument\", ], ) Create Create a document (insert it) document = DocumentTestModel( test_int=42, test_list=[SubDocument(test_str=\"foo\"), SubDocument(test_str=\"bar\")], test_str=\"kipasa\", ) await document.create() Insert one document document = DocumentTestModel( test_int=42, test_list=[SubDocument(test_str=\"foo\"), SubDocument(test_str=\"bar\")], test_str=\"kipasa\", ) await DocumentTestModel.insert_one(document) Insert many documents document_1 = DocumentTestModel( test_int=42, test_list=[SubDocument(test_str=\"foo\"), SubDocument(test_str=\"bar\")], test_str=\"kipasa\", ) document_2 = DocumentTestModel( test_int=42, test_list=[SubDocument(test_str=\"foo\"), SubDocument(test_str=\"bar\")], test_str=\"kipasa\", ) await DocumentTestModel.insert_many([document_1, document_2]) Find Get the document document = await DocumentTestModel.get(DOCUMENT_ID) Find one document document = await DocumentTestModel.find_one({\"test_str\": \"kipasa\"}) Find many documents async for document in DocumentTestModel.find_many({\"test_str\": \"uno\"}, limit=100): print(document) OR documents = await DocumentTestModel.find_many({\"test_str\": \"uno\"}, sort=\"test_int\").to_list() Parameters: filter_query: The selection criteria skip: The number of documents to omit. limit: The maximum number of results to return. sort: A key or a list of (key, direction) pairs specifying the sort order for this query. Find all the documents async for document in DocumentTestModel.find_all(limit=100): print(document) OR documents = await DocumentTestModel.find_all(skip=10).to_list() Parameters: skip: The number of documents to omit. limit: The maximum number of results to return. sort: A key or a list of (key, direction) pairs specifying the sort order for this query. Update Replace the document (full update) document.test_str = \"REPLACED_VALUE\" await document.replace() Replace one document Replace one doc data by another new_doc = DocumentTestModel( test_int=0, test_str='REPLACED_VALUE', test_list=[] ) await DocumentTestModel.replace_one({\"_id\": document.id}, new_doc) Update the document (partial update) in this example, I'll add an item to the document's \"test_list\" field to_insert = SubDocument(test_str=\"test\") await document.update(update_query={\"$push\": {\"test_list\": to_insert.dict()}}) Update one document await DocumentTestModel.update_one( update_query={\"$set\": {\"test_list.$.test_str\": \"foo_foo\"}}, filter_query={\"_id\": document.id, \"test_list.test_str\": \"foo\"}, ) Update many documents await DocumentTestModel.update_many( update_query={\"$set\": {\"test_str\": \"bar\"}}, filter_query={\"test_str\": \"foo\"}, ) Update all the documents await DocumentTestModel.update_all( update_query={\"$set\": {\"test_str\": \"bar\"}} ) Delete Delete the document await document.delete() Delete one documents await DocumentTestModel.delete_one({\"test_str\": \"uno\"}) Delete many documents await DocumentTestModel.delete_many({\"test_str\": \"dos\"}) Delete all the documents await DocumentTestModel.delete_all() Aggregate async for item in DocumentTestModel.aggregate( [{\"$group\": {\"_id\": \"$test_str\", \"total\": {\"$sum\": \"$test_int\"}}}] ): print(item) OR class OutputItem(BaseModel): id: str = Field(None, alias=\"_id\") total: int async for item in DocumentTestModel.aggregate( [{\"$group\": {\"_id\": \"$test_str\", \"total\": {\"$sum\": \"$test_int\"}}}], item_model=OutputModel ): print(item) OR results = await DocumentTestModel.aggregate( [{\"$group\": {\"_id\": \"$test_str\", \"total\": {\"$sum\": \"$test_int\"}}}], item_model=OutputModel ).to_list() Collection setup Optionally collection of the document could be set up by the internal Collection class. Follow the examples: Collection name The name of the collection could be set up by the field name of the Collection class. By default, the collection will have the same name as the document class. class DocumentTestModelWithCustomCollectionName(Document): test_int: int test_list: List[SubDocument] test_str: str class Collection: name = \"custom_collection\" Indexes Simple indexes To setup an index over a single field the Indexed function can be used to wrap the type: from beanie import Indexed class DocumentTestModelWithIndex(Document): test_int: Indexed(int) test_list: List[SubDocument] test_str: str Complex indexes More complex indexes can be set up by the indexes field in a Collection class. It is a list where items could be: single key. Name of the document's field list of (key, direction) pairs. Key - string, name of the document's field. Direction - pymongo direction ( example: pymongo.ASCENDING ) pymongo.IndexModel instance - the most flexible option. Documentation class DocumentTestModelWithIndex(Document): test_int: int test_list: List[SubDocument] test_str: str class Collection: indexes = [ \"test_int\", [ (\"test_int\", pymongo.ASCENDING), (\"test_str\", pymongo.DESCENDING), ], IndexModel( [(\"test_str\", pymongo.DESCENDING)], name=\"test_string_index_DESCENDING\", ), ] Complex and simple indices can be used in tandem. Use Motor Collection In case, when you need more low-level control, you can get access to the engine of the Beanie Document - AsyncIO Motor Collection motor_collection = DocumentTestModel.get_motor_collection() await motor_collection.drop_index(\"index_name\")","title":"Quick Start"},{"location":"#_1","text":"Beanie - is an asynchronous ODM for MongoDB, based on Motor and Pydantic . It uses an abstraction over Pydantic models and Motor collections to work with the database. Class Document allows to create, replace, update, get, find and aggregate. Here you can see, how to use Beanie, in simple examples:","title":""},{"location":"#installation","text":"","title":"Installation"},{"location":"#pip","text":"pip install beanie","title":"PIP"},{"location":"#poetry","text":"poetry add beanie","title":"Poetry"},{"location":"#usage","text":"","title":"Usage"},{"location":"#init","text":"import asyncio from typing import List import motor from beanie import Document from beanie import init_beanie from pydantic import BaseModel # CREATE BEANIE DOCUMENT STRUCTURE class SubDocument(BaseModel): test_str: str class DocumentTestModel(Document): test_int: int test_list: List[SubDocument] test_str: str async def main(): # CREATE MOTOR CLIENT AND DB client = motor.motor_asyncio.AsyncIOMotorClient( \"mongodb://user:pass@host:27017/db\", serverSelectionTimeoutMS=100 ) db = client.beanie_db # INIT BEANIE await init_beanie(database=db, document_models=[DocumentTestModel]) asyncio.run(main()) init_beanie supports not only list of classes for the document_models parameter, but also strings with the dot separated paths. Example: await init_beanie( database=db, document_models=[ \"app.models.DemoDocument\", ], )","title":"Init"},{"location":"#create","text":"","title":"Create"},{"location":"#create-a-document-insert-it","text":"document = DocumentTestModel( test_int=42, test_list=[SubDocument(test_str=\"foo\"), SubDocument(test_str=\"bar\")], test_str=\"kipasa\", ) await document.create()","title":"Create a document (insert it)"},{"location":"#insert-one-document","text":"document = DocumentTestModel( test_int=42, test_list=[SubDocument(test_str=\"foo\"), SubDocument(test_str=\"bar\")], test_str=\"kipasa\", ) await DocumentTestModel.insert_one(document)","title":"Insert one document"},{"location":"#insert-many-documents","text":"document_1 = DocumentTestModel( test_int=42, test_list=[SubDocument(test_str=\"foo\"), SubDocument(test_str=\"bar\")], test_str=\"kipasa\", ) document_2 = DocumentTestModel( test_int=42, test_list=[SubDocument(test_str=\"foo\"), SubDocument(test_str=\"bar\")], test_str=\"kipasa\", ) await DocumentTestModel.insert_many([document_1, document_2])","title":"Insert many documents"},{"location":"#find","text":"","title":"Find"},{"location":"#get-the-document","text":"document = await DocumentTestModel.get(DOCUMENT_ID)","title":"Get the document"},{"location":"#find-one-document","text":"document = await DocumentTestModel.find_one({\"test_str\": \"kipasa\"})","title":"Find one document"},{"location":"#find-many-documents","text":"async for document in DocumentTestModel.find_many({\"test_str\": \"uno\"}, limit=100): print(document) OR documents = await DocumentTestModel.find_many({\"test_str\": \"uno\"}, sort=\"test_int\").to_list() Parameters: filter_query: The selection criteria skip: The number of documents to omit. limit: The maximum number of results to return. sort: A key or a list of (key, direction) pairs specifying the sort order for this query.","title":"Find many documents"},{"location":"#find-all-the-documents","text":"async for document in DocumentTestModel.find_all(limit=100): print(document) OR documents = await DocumentTestModel.find_all(skip=10).to_list() Parameters: skip: The number of documents to omit. limit: The maximum number of results to return. sort: A key or a list of (key, direction) pairs specifying the sort order for this query.","title":"Find all the documents"},{"location":"#update","text":"","title":"Update"},{"location":"#replace-the-document-full-update","text":"document.test_str = \"REPLACED_VALUE\" await document.replace()","title":"Replace the document (full update)"},{"location":"#replace-one-document","text":"Replace one doc data by another new_doc = DocumentTestModel( test_int=0, test_str='REPLACED_VALUE', test_list=[] ) await DocumentTestModel.replace_one({\"_id\": document.id}, new_doc)","title":"Replace one document"},{"location":"#update-the-document-partial-update","text":"in this example, I'll add an item to the document's \"test_list\" field to_insert = SubDocument(test_str=\"test\") await document.update(update_query={\"$push\": {\"test_list\": to_insert.dict()}})","title":"Update the document (partial update)"},{"location":"#update-one-document","text":"await DocumentTestModel.update_one( update_query={\"$set\": {\"test_list.$.test_str\": \"foo_foo\"}}, filter_query={\"_id\": document.id, \"test_list.test_str\": \"foo\"}, )","title":"Update one document"},{"location":"#update-many-documents","text":"await DocumentTestModel.update_many( update_query={\"$set\": {\"test_str\": \"bar\"}}, filter_query={\"test_str\": \"foo\"}, )","title":"Update many documents"},{"location":"#update-all-the-documents","text":"await DocumentTestModel.update_all( update_query={\"$set\": {\"test_str\": \"bar\"}} )","title":"Update all the documents"},{"location":"#delete","text":"","title":"Delete"},{"location":"#delete-the-document","text":"await document.delete()","title":"Delete the document"},{"location":"#delete-one-documents","text":"await DocumentTestModel.delete_one({\"test_str\": \"uno\"})","title":"Delete one documents"},{"location":"#delete-many-documents","text":"await DocumentTestModel.delete_many({\"test_str\": \"dos\"})","title":"Delete many documents"},{"location":"#delete-all-the-documents","text":"await DocumentTestModel.delete_all()","title":"Delete all the documents"},{"location":"#aggregate","text":"async for item in DocumentTestModel.aggregate( [{\"$group\": {\"_id\": \"$test_str\", \"total\": {\"$sum\": \"$test_int\"}}}] ): print(item) OR class OutputItem(BaseModel): id: str = Field(None, alias=\"_id\") total: int async for item in DocumentTestModel.aggregate( [{\"$group\": {\"_id\": \"$test_str\", \"total\": {\"$sum\": \"$test_int\"}}}], item_model=OutputModel ): print(item) OR results = await DocumentTestModel.aggregate( [{\"$group\": {\"_id\": \"$test_str\", \"total\": {\"$sum\": \"$test_int\"}}}], item_model=OutputModel ).to_list()","title":"Aggregate"},{"location":"#collection-setup","text":"Optionally collection of the document could be set up by the internal Collection class. Follow the examples:","title":"Collection setup"},{"location":"#collection-name","text":"The name of the collection could be set up by the field name of the Collection class. By default, the collection will have the same name as the document class. class DocumentTestModelWithCustomCollectionName(Document): test_int: int test_list: List[SubDocument] test_str: str class Collection: name = \"custom_collection\"","title":"Collection name"},{"location":"#indexes","text":"","title":"Indexes"},{"location":"#simple-indexes","text":"To setup an index over a single field the Indexed function can be used to wrap the type: from beanie import Indexed class DocumentTestModelWithIndex(Document): test_int: Indexed(int) test_list: List[SubDocument] test_str: str","title":"Simple indexes"},{"location":"#complex-indexes","text":"More complex indexes can be set up by the indexes field in a Collection class. It is a list where items could be: single key. Name of the document's field list of (key, direction) pairs. Key - string, name of the document's field. Direction - pymongo direction ( example: pymongo.ASCENDING ) pymongo.IndexModel instance - the most flexible option. Documentation class DocumentTestModelWithIndex(Document): test_int: int test_list: List[SubDocument] test_str: str class Collection: indexes = [ \"test_int\", [ (\"test_int\", pymongo.ASCENDING), (\"test_str\", pymongo.DESCENDING), ], IndexModel( [(\"test_str\", pymongo.DESCENDING)], name=\"test_string_index_DESCENDING\", ), ] Complex and simple indices can be used in tandem.","title":"Complex indexes"},{"location":"#use-motor-collection","text":"In case, when you need more low-level control, you can get access to the engine of the Beanie Document - AsyncIO Motor Collection motor_collection = DocumentTestModel.get_motor_collection() await motor_collection.drop_index(\"index_name\")","title":"Use Motor Collection"},{"location":"changelog/","text":"Changelog Beanie project changes 0.3.3 - 2021-03-25 Added Simple indexes via type hints Documentation - Thanks Joran van Apeldoorn 0.3.2 - 2021-03-25 Added init_beanie supports also lists of strings with model paths as the document_models parameter. Documentation - Thanks Mohamed Nesredin 0.3.1 - 2021-03-21 Added skip , limit and sort parameters in the find_many and find_all methods. Documentation 0.3.0 - 2021-03-19 Added Collection - internal class of the Document to set up additional properties. Documentation . Indexes support. Documentation . Changed Breaking change: init_beanie is async function now. Deprecated Internal DocumentMeta class. Will be removed in 0.4.0 .","title":"Changelog"},{"location":"changelog/#changelog","text":"Beanie project changes","title":"Changelog"},{"location":"changelog/#033-2021-03-25","text":"","title":"0.3.3 - 2021-03-25"},{"location":"changelog/#added","text":"Simple indexes via type hints Documentation - Thanks Joran van Apeldoorn","title":"Added"},{"location":"changelog/#032-2021-03-25","text":"","title":"0.3.2 - 2021-03-25"},{"location":"changelog/#added_1","text":"init_beanie supports also lists of strings with model paths as the document_models parameter. Documentation - Thanks Mohamed Nesredin","title":"Added"},{"location":"changelog/#031-2021-03-21","text":"","title":"0.3.1 - 2021-03-21"},{"location":"changelog/#added_2","text":"skip , limit and sort parameters in the find_many and find_all methods. Documentation","title":"Added"},{"location":"changelog/#030-2021-03-19","text":"","title":"0.3.0 - 2021-03-19"},{"location":"changelog/#added_3","text":"Collection - internal class of the Document to set up additional properties. Documentation . Indexes support. Documentation .","title":"Added"},{"location":"changelog/#changed","text":"Breaking change: init_beanie is async function now.","title":"Changed"},{"location":"changelog/#deprecated","text":"Internal DocumentMeta class. Will be removed in 0.4.0 .","title":"Deprecated"}]}